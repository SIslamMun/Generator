# ============================================================================
# CODE QA GENERATION PROMPT
# Generates BOTH code understanding AND user-facing usage questions
# ============================================================================

prompt: |
  Create question-answer pairs from this source code for LLM training.

  Rules:
  1. Generate a MIX of code understanding AND practical usage questions
  2. Answers must be directly supported by the code
  3. Create {n_pairs_min}-{n_pairs_max} diverse question-answer pairs
  4. IMPORTANT: Work with whatever code is provided, even if incomplete

  **CRITICAL - ONLY USE INFORMATION FROM THE CODE:**
  - ONLY generate QA pairs using information EXPLICITLY shown in the code
  - Use function/class/variable names EXACTLY as they appear in the code
  - Do NOT invent function parameters, return types, or behaviors not shown
  - If a command is shown as `tool cmd`, use exactly that - don't change it
  - Never guess or make up details not present in the source code

  **PREVENTING HALLUCINATIONS - VERY IMPORTANT:**
  
  1. **DO NOT INVENT ARGUMENTS:**
     - If code shows `def build():` with no params, don't add `build(name, path)`
     - If CLI shows `tool build`, don't add `tool build <arg1> <arg2>`
     - Only include parameters that are EXPLICITLY defined in the code
  
  2. **DO NOT CONFLATE CONCEPTS:**
     - Parameters in one function don't automatically apply to other functions
     - A variable for a file path is different from a direct value
     - Don't mix up parameters from different classes or functions
  
  3. **DISTINGUISH CONTEXT CAREFULLY:**
     - Parameters defined in one class/function are specific to THAT class/function
     - Configuration for one module doesn't apply to other modules
     - Each function/class has its own specific parameters - don't cross-contaminate

  **GENERATE TWO TYPES OF QUESTIONS:**

  **TYPE 1 - USER QUESTIONS (prioritize these if CLI/usage info exists):**
  - "How do I use [feature]?" - practical usage from docstrings/comments
  - "What command [does action]?" - if CLI commands are shown
  - "What parameters does [function] accept?" - for user-facing functions
  - "How do I configure [feature]?" - from config handling code

  **TYPE 2 - CODE UNDERSTANDING:**
  - "What does `function_name()` do?" - internal behavior
  - "How does `ClassName` handle X?" - implementation details
  - "What happens when X condition occurs?" - error handling

  **CRITICAL: If code contains CLI commands, argument parsing, or usage examples:**
  - ALWAYS generate questions about how to USE those commands
  - Include the EXACT command syntax as shown in the code
  - Example: If code has `argparse` with `--output`, ask "What does the --output flag do?"

  **WHEN IN DOUBT:**
  - If you're not 100% sure about exact syntax/parameters, skip that question
  - Better to generate fewer accurate pairs than many with invented details
  - If code only shows partial info, only describe what's actually visible

  **GOOD question examples (adapt to actual code content):**
  - "How do I [action] using [tool]?" (user-facing)
  - "What command [does action]?" (CLI usage)
  - "What does the `method_name()` method do?" (code understanding)
  - "What parameters does `function_name()` accept?" (both)

  **DO NOT** create questions about:
  - Import statements alone
  - License headers or copyright notices
  - Author names or version numbers
  - Questions answerable with single words

  **ANSWER REQUIREMENTS:**
  - Minimum 2-3 sentences
  - For USER questions: Include exact commands/syntax from the code
  - For CODE questions: Reference specific code elements
  - Use markdown code formatting for commands

  **IF THE CODE IS TOO SHORT OR LACKS ACTIONABLE CONTENT:**
  If the code is just imports, license headers, empty files, or trivial boilerplate
  with no meaningful functions/classes/documentation, return an empty array: []
  Do NOT apologize or explain - just return []

  **VALIDATION CHECKLIST (before returning):**
  ✓ Did you generate user-facing questions if CLI/usage info exists?
  ✓ Do answers include exact command syntax when applicable?
  ✓ Is each answer 2-3+ sentences with specific details?
  ✓ Would this help someone USE the tool, not just understand internals?
  ✓ Are ALL parameters/arguments taken EXACTLY from the code, not invented?

  Return ONLY valid JSON array format (no markdown, no explanation, no comments):

  **GOOD EXAMPLE:**
  [
    {{
      "question": "How do I [action] using [tool]?",
      "answer": "To [action], use the command `tool subcommand <args>`. This [explanation of what it does]. You can then [follow-up action] using `tool another-subcommand`."
    }},
    {{
      "question": "What does the `method_name()` method do in the ClassName class?",
      "answer": "The `method_name()` method [description of behavior]. It [implementation detail]. If [condition], it [error handling or special case]."
    }}
  ]

  **BAD EXAMPLE (cross-contaminating parameters from different parts of code):**
  [
    {{
      "question": "How do I initialize the tool?",
      "answer": "Use `tool init <param_a> <param_b>` to initialize."
    }}
  ]
  ^ BAD: If param_a and param_b are from a DIFFERENT function/class, don't use them for init!

  Source Code:
  {text}
